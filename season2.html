<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body{
            margin: 0;
            display: flex;
            align-items: center;
            flex-direction: column;
            background-color: lightgray;
            overflow: hidden;
        }
    </style>
</head>
<body>
<canvas id="gameAria"></canvas>
<canvas id="touchAria"></canvas>
<script>
const gCan = document.getElementById("gameAria");
const gCtx = gCan.getContext("2d");
const tCan = document.getElementById("touchAria");
const tCtx = tCan.getContext("2d");

gCan.width = 350
gCan.height = 500
gCan.style.border = "2px solid #555"

tCan.width = 350;
tCan.height = 150;
tCan.style.border = "2px solid #555"
tCan.style.borderTop = "none"
tCan.style.borderRadius = "0 0 50px 50px"

gCan.style.marginTop = `${(window.innerHeight - gCan.height - tCan.height)/2}px`
tCan.style.marginBottom = `${(window.innerHeight - gCan.height - tCan.height)/2}px`


gCtx.fillStyle = "dimgray";
gCtx.fillRect(0,0,gCan.width,gCan.height)


class TouchPanel {
    constructor(can){
        this.x = 0;
        this.y = 0;
        this.w = can.width;
        this.h = can.height;

        //drawDot
        this.dotInterval = 15;
        this.dotR = 2;
        this.margin = 20

        //setEvent
        this.can = can;
        this.touch = {
            x:null,y:null,start:false,touch:false,
            sx:null,sy:null,swipe:null
        }

        this.can.addEventListener("touchstart",e=>{
            const {x,y} = this.getOffset({ev:e,el:this.can})
            this.touch.start = true;
            this.touch.touch = true;
            this.touch.x = x;
            this.touch.y = y;
            this.touch.sx = x;
            this.touch.sy = y;
        })
        this.can.addEventListener("touchmove",e=>{
            const {x,y} = this.getOffset({ev:e,el:this.can})

            this.touch.touch = true;
            this.touch.x = x;
            this.touch.y = y;
        })
        this.can.addEventListener("touchend",e=>{
            const dx = this.touch.x - this.touch.sx;
            const dy = this.touch.y - this.touch.sy;

            if(Math.abs(dx)>Math.abs(dy)){
                this.touch.swipe = dx > 0 ? "right" : "left"
            }else{
                this.touch.swipe = dy > 0 ? "down" : "up"
            }
            this.touch.touch = false;
            this.touch.x = null;
            this.touch.y = null;
            this.touch.sx = null;
            this.touch.sy = null;
        })
    }
    getOffset({ev:ev,el:el}){
        const posX = ev.changedTouches[0].clientX;
        const posY = ev.changedTouches[0].clientY;
        const rect = el.getBoundingClientRect();
        return {x:posX-rect.left,y:posY-rect.top}
    }
    update(){

        //touch Reset
        this.touch.start = false;
        this.touch.swipe = false;
    }
    draw(){

        const col = Math.floor((this.w-this.margin*2)/this.dotInterval);
        const row = Math.floor((this.h-this.margin*2)/this.dotInterval)

        const marginLeft = this.margin + (this.w-this.margin*2)%this.dotInterval /2
        const marginTop =  this.margin + (this.h-this.margin*2)%this.dotInterval /2

        tCtx.fillStyle = "gray"
        for(let y=0; y<=row; y++){
            for(let x=0; x<=col; x++){
                tCtx.beginPath();
                tCtx.arc(x*this.dotInterval+marginLeft,y*this.dotInterval+marginTop,this.dotR,0,Math.PI*2)
                tCtx.fill();
            }
        }

        tCtx.fillStyle = "rgba(0,0,0,0.2)";
        tCtx.fillRect(this.x,this.y,this.w,this.h)
    }
}


class Ball {
    constructor(can,puddle){
        this.can = can;
        this.puddle = puddle;
        this.x = this.puddle.x+this.puddle.w/2;
        this.y = this.puddle.y;
        this.r = 5;

        this.xBef = this.x;
        this.yBef = this.y;


        this.dx = -0.5;
        this.dy = -0.5;
        this.speed = 5

        this.angle = 0;

        this.release = false;
    }
    update(){
        this.xBef = this.x;
        this.yBef = this.y;
        if(tStatus.swipe === "up")this.release = true;
        if(this.release){
            this.x += this.dx* this.speed;
            this.y += this.dy* this.speed
        }else{
            this.x = this.puddle.x+this.puddle.w/2;
            this.y = this.puddle.y;
        }

        //上左右の反射
        if(this.x<this.r){this.x = this.r;this.dx *= -1;}
        else if(this.x>this.can.width-this.r){this.x = this.can.width-this.r; this.dx *= -1;}
        if(this.y<this.r){this.y = this.r;this.dy *= -1;}
        //パドル反射
        else if(this.y>this.puddle.y-this.r && this.x>this.puddle.x && this.x<this.puddle.x+this.puddle.w){
            
   


            this.y = this.puddle.y-this.r;
            this.dy *= -1



        }
        //下判定
        else if(this.y+this.r>this.can.height)console.log("game over")


        this.angle = Math.atan2(this.y-this.yBef,this.x-this.xBef)
    }

    draw(){
        gCtx.lineWidth = 1
        gCtx.fillStyle = "#07F5E1";
        gCtx.beginPath();
        gCtx.arc(this.x,this.y,this.r,0,Math.PI*2)
        gCtx.fill();
        gCtx.stroke();
    }
}

class Puddle {
    static width = 100;
    static height = 30;
    constructor(can){
        this.can = can;

        this.w = Puddle.width;
        this.h = Puddle.height;
        this.x = can.width/2 - this.w/2;
        this.y = can.height - 50;

        this.sx = this.x;
        this.sensitivity = 1.8
    }
    update(){
        let gap = tStatus.x - tStatus.sx;
        if(tStatus.start)this.sx = this.x;
        if(tStatus.touch)this.x = this.sx + gap*this.sensitivity
        
        if(this.x<-this.w/2)this.x = -this.w/2
        else if(this.x>this.can.width-this.w/2)this.x = this.can.width-this.w/2


    }
    draw(){
        const gradient = gCtx.createLinearGradient(this.x, this.y, this.x+this.w, this.y+this.h);
        gradient.addColorStop(0, '#0BB2D9');
        gradient.addColorStop(1, '#0CF8E5');
        gCtx.fillStyle = gradient;
        gCtx.strokeStyle = "blue"
        gCtx.lineWidth = 2
        gCtx.fillRect(this.x,this.y,this.w,this.h)
        gCtx.strokeRect(this.x,this.y,this.w,this.h)
    }

}

class Block{
    constructor(x,y,w,h){
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;

        this.hp = 1;
        this.colors = ["black","orange"]
    }
    draw(){
        gCtx.save();
        const shadowWidth = 5;
        gCtx.lineWidth = 3;

        gCtx.fillStyle = this.colors[this.hp];//矩形全体
        gCtx.beginPath();
        gCtx.moveTo(this.x,this.y)
        gCtx.lineTo(this.x+this.w,this.y)
        gCtx.lineTo(this.x+this.w,this.y+this.h)
        gCtx.lineTo(this.x,this.y+this.h)
        gCtx.closePath();
        gCtx.fill();
        
        gCtx.fillStyle = "rgba(0,0,0,0.3)";//右下影
        gCtx.beginPath();
        gCtx.moveTo(this.x+this.w,this.y);
        gCtx.lineTo(this.x+this.w,this.y+this.h);
        gCtx.lineTo(this.x,this.y+this.h);
        gCtx.lineTo(this.x+shadowWidth,this.y+this.h-shadowWidth);
        gCtx.lineTo(this.x+this.w-shadowWidth,this.y+this.h-shadowWidth);
        gCtx.lineTo(this.x+this.w-shadowWidth,this.y+shadowWidth);
        gCtx.lineTo(this.x+this.w,this.y);
        gCtx.fill();

        gCtx.fillStyle = "rgba(255,255,255,0.4)"//左上
        gCtx.beginPath();
        gCtx.moveTo(this.x,this.y+this.h);
        gCtx.lineTo(this.x,this.y);
        gCtx.lineTo(this.x+this.w,this.y);
        gCtx.lineTo(this.x+this.w-shadowWidth,this.y+shadowWidth);
        gCtx.lineTo(this.x+shadowWidth,this.y+shadowWidth);
        gCtx.lineTo(this.x+shadowWidth,this.y+this.h-shadowWidth);
        gCtx.fill();

        gCtx.strokeStyle = this.colors[this.hp];//角の線
        gCtx.lineWidth = 1
        gCtx.beginPath();
        gCtx.moveTo(this.x,this.y);
        gCtx.lineTo(this.x+shadowWidth,this.y+shadowWidth);
        gCtx.lineTo(this.x+this.w-shadowWidth,this.y+this.h-shadowWidth);
        gCtx.lineTo(this.x+this.w,this.y+this.h);
        gCtx.stroke();
        gCtx.beginPath();
        gCtx.moveTo(this.x+this.w,this.y);
        gCtx.moveTo(this.x+this.w-shadowWidth,this.y+shadowWidth);
        gCtx.moveTo(this.x+shadowWidth,this.y+this.h-shadowWidth);
        gCtx.lineTo(this.x,this.y+this.h);
        gCtx.stroke();
        gCtx.strokeStyle = this.strokeColor;
        gCtx.strokeRect(this.x,this.y,this.w,this.h)

        gCtx.restore();
    }
}


class Game{
    constructor(gCan,tCan){

        this.puddle = new Puddle(gCan);
        this.ball = new Ball(gCan,this.puddle);

        this.blocks = [];

        for(let i=0; i<10; i++){
            for(let j=0; j<12; j++){
                this.blocks.push(new Block(j*50,i*10,50,10))
            }
        }
        

    }
    render(){
        
        this.puddle.draw();
        this.puddle.update()
        this.ball.draw();
        this.ball.update();


        this.blocks = this.blocks.filter(b => !b.delete)
        this.blocks.forEach(block => {
            block.draw();

            const blockSegments = [
                {A:{x:block.x,y:block.y},B:{x:block.x+block.w,y:block.y}},
                {A:{x:block.x+block.w,y:block.y},B:{x:block.x+block.w,y:block.y+block.h}},
                {A:{x:block.x+block.w,y:block.y+block.h},B:{x:block.x,y:block.y+block.h}},
                {A:{x:block.x,y:block.y+block.h},B:{x:block.x,y:block.y}},
            ]
            blockSegments.forEach(seg=>{
                //seg.A,B ball=C,ballBef=D
                //AB,AC,AD
                //CD,CA,CB
                let ax = seg.A.x;
                let ay = seg.A.y;
                let bx = seg.B.x;
                let by = seg.B.y;
                let cx = this.ball.x+Math.cos(this.ball.angle)*this.ball.r
                let cy = this.ball.y+Math.sin(this.ball.angle)*this.ball.r
                let dx = this.ball.xBef-Math.cos(this.ball.angle)*this.ball.r
                let dy = this.ball.yBef-Math.sin(this.ball.angle)*this.ball.r
                let vAB = {x:bx-ax,y:by-ay};
                let vAC = {x:cx-ax,y:cy-ay}
                let vAD = {x:dx-ax,y:dy-ay}
                let vCD = {x:dx-cx,y:dy-cy}
                let vCA = {x:ax-cx,y:ay-cy}
                let vCB = {x:bx-cx,y:by-cy}
                let crossProduct1 = vAB.x*vAC.y - vAB.y*vAC.x
                let crossProduct2 = vAB.x*vAD.y - vAB.y*vAD.x
                let crossProduct3 = vCD.x*vCA.y - vCD.y*vCA.x
                let crossProduct4 = vCD.x*vCB.y - vCD.y*vCB.x
                let f = false;
                if(Math.sign(crossProduct1)<0){
                    if(Math.sign(crossProduct2)>0){
                        f = true;
                    }
                }else{
                    if(Math.sign(crossProduct2)<0){
                        f = true;
                    }
                }
                if(f){
                    if(Math.sign(crossProduct3)<0){
                        if(Math.sign(crossProduct4)>0){
                            block.delete = true;
                            this.ball.dx = Math.cos(this.ball.angle);
                            this.ball.dy = -this.ball.dy;
                        }
                    }else{
                        if(Math.sign(crossProduct4)<0){
                            block.delete = true;
                            this.ball.dx = Math.cos(this.ball.angle)
                            this.ball.dy = -this.ball.dy;
                        }
                    }
                }
            })
        })

    }
}


const touchPanel = new TouchPanel(tCan)
const tStatus = touchPanel.touch
const game = new Game(gCan, tCan)


function animate(){
    gCtx.clearRect(0,0,gCan.width,gCan.height)
    tCtx.clearRect(0,0,tCan.width,tCan.height)

    game.render();
    touchPanel.draw();
    touchPanel.update();

    requestAnimationFrame(animate);
}

animate();


function lineCircleCollision(A,B,circle) {//{A:x,y}{circle:x,y,r}
    function len_vec2(vec) {
      return vec[0] * vec[0] + vec[1] * vec[1];
    }
    
    function inner_prod(vec1, vec2) {
      return vec1[0] * vec2[0] + vec1[1] * vec2[1];
    }
  
    var pos_o = [circle.x, circle.y];
    var r = circle.r;
    var pos_a = [A.x, A.y];
    var pos_b = [B.x, B.y];
  
    if (pos_a[0] === pos_b[0] && pos_a[1] === pos_b[1]) {
      return false;
    }
  
    if (r <= 0) {
      return false;
    }
  
    var vec_oa = [pos_a[0] - pos_o[0], pos_a[1] - pos_o[1]];
    var vec_ob = [pos_b[0] - pos_o[0], pos_b[1] - pos_o[1]];
  
    var len_oa2 = len_vec2(vec_oa);
    var len_ob2 = len_vec2(vec_ob);
    var inner_ab = inner_prod(vec_oa, vec_ob);
  
    var a = len_oa2 + len_ob2 - 2 * inner_ab;
    var b = -2 * len_oa2 + 2 * inner_ab;
    var c = len_oa2 - r * r;
  
    var det = b * b - 4 * a * c;
    if (det < 0) {
      return false;
    }
  
    var s1 = (-b - Math.sqrt(det)) / (2 * a);
    var s2 = (-b + Math.sqrt(det)) / (2 * a);
  
    return (s1 <= 1) && (0 <= s2);
  }

  
  function positionLC(A,B,C) {
    const v1 = {x:B.x-A.x,y:B.y-A.y};
    const v2 = {x:C.x-A.x,y:C.y-A.y};
  
    const crossProduct = v1.x*v2.y - v1.y*v2.x;
  
    return crossProduct>0
  }

</script>
</body>
</html>
